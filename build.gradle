import groovy.text.GStringTemplateEngine
import org.openapitools.generator.gradle.plugin.tasks.GenerateTask
import org.yaml.snakeyaml.Yaml

plugins {
    id "nebula.lint"
    id "com.github.ben-manes.versions"
    id "org.openapi.generator"
    id "java"
    id "war"
    id "distribution"
    id "maven-publish"
    id "org.owasp.dependencycheck"
    id "jacoco"
    id "org.sonarqube"

    // The following are plugins are plugins we wrote in the buildSrc folder
    id "org.candlepin.gradle.gettext"
    id "org.candlepin.gradle.msgfmt"
    id "org.candlepin.gradle.SpecVersion"
    id "checkstyle-conventions"
    id "test-logging-conventions"
}

apply from: "dependencies.gradle"

group = "org.candlepin"

ext {
    api_spec_path = "${projectDir}/api/candlepin-api-spec.yaml"
    config_file = "${projectDir}/api/candlepin-api-config.json"

    cpdb_username = "candlepin"
    cpdb_password = ""
    db_name = "candlepin"

    if (project.findProperty("hidden_resources")) {
        hidden_resources = project.findProperty("hidden_resources")
    }

    if (project.findProperty("hidden_capabilities")) {
        hidden_capabilities = project.findProperty("hidden_capabilities")
    }

    if (!project.findProperty("db_host") ||
            (project.findProperty("db_host") && "".equals(project.findProperty("db_host")))) {

        db_host = "localhost"
    }

    if (project.findProperty("app_db_name") && !"".equals(project.findProperty("app_db_name"))) {
        db_name = project.findProperty("app_db_name")
    }

    // If MYSQL set up the mysql stuff else set up postgres (default)
    if (project.findProperty("database_server") == "mysql") {
        jdbc_driver_class = "org.mariadb.jdbc.Driver"
        jdbc_dialect = "org.hibernate.dialect.MySQL5InnoDBDialect"
        jdbc_quartz_driver_class = "org.quartz.impl.jdbcjobstore.StdJDBCDelegate"
        jdbc_url = "jdbc:mariadb://${db_host}/${db_name}"
    } else {
        jdbc_driver_class = "org.postgresql.Driver"
        jdbc_dialect = "org.hibernate.dialect.PostgreSQL92Dialect"
        jdbc_quartz_driver_class = "org.quartz.impl.jdbcjobstore.PostgreSQLDelegate"
        jdbc_url = "jdbc:postgresql://${db_host}/${db_name}"
    }

    external_broker = "true".equals(project.findProperty("external_broker"))
    async_scheduler_enabled = !project.findProperty("async_scheduler_enabled") ||
        "true".equals(project.findProperty("async_scheduler_enabled"))
}

dependencies {
    // Cache
    implementation libraries["caffeine"]

    // Commons
    implementation libraries["commonsCodec"]
    implementation libraries["commonsCollections"]
    implementation libraries["commonsIo"]
    implementation libraries["commonsLang"]

    // Collections
    implementation libraries["guava"]

    // Gettext libraries used for internationalization & translation
    implementation libraries["gettext"]

    // Guice Libraries
    implementation libraries["guiceServlet"]
    implementation libraries["guicePersist"]

    // Jackson
    implementation libraries["jacksonJaxrs"]
    implementation libraries["jacksonJsonSchema"]
    implementation libraries["jacksonHibernate"]
    implementation libraries["jacksonJdk8"]
    implementation libraries["jacksonJsr310"]
    implementation libraries["jacksonYaml"]
    implementation libraries["jacksonXml"]

    // Bean validation API is explicitly added to this version
    // This is a transitive dependency of
    // com.fasterxml.jackson.module:jackson-module-jsonSchema
    implementation libraries["javaxValidation"]

    // Javax
    implementation libraries["hibernate"]
    implementation libraries["javaxAnnotation"]

    // Liquibase
    implementation libraries["liquibase"]
    implementation libraries["picocli"]

    // Logging
    implementation libraries["logback"]
    // Artifacts that bridge other logging frameworks to slf4j. Mime4j uses
    // JCL for example.
    implementation libraries["jclOverSlf4j"]
    implementation libraries["log4jOverSlf4j"]
    implementation libraries["logstash"]

    // Oauth
    implementation libraries["oauth"]

    // Resteasy
    implementation libraries["resteasyGuice"]
    implementation libraries["resteasyAtom"]
    implementation libraries["resteasyMultipart"]
    implementation libraries["resteasyValidator"]

    implementation libraries["javaxRs"]

    // Sun jaxb
    implementation libraries["jaxb"]
    implementation libraries["jaxbCore"]

    // Swagger
    implementation libraries["swagger"]

    // Validator
    implementation libraries["hibernateValidator"]
    implementation libraries["hibernateValidatorProcessor"]

    // Hibernate
    implementation libraries["hibernateC3p0"]
    // Ehcache (for use with hibernate primarily)
    implementation libraries["hibernateJcache"]
    implementation libraries["ehcache"]
    implementation libraries["javaxCache"]

    // Artemis server & client
    implementation libraries["artemisServer"]
    implementation libraries["artemisStomp"]

    // Javascript Engine
    implementation libraries["rhino"]

    implementation libraries["quartz"]

    // Keycloak
    implementation libraries["keycloak"]

    // Hibernate JPA integration
    implementation libraries["hibernateJpamodelgen"]
    annotationProcessor libraries["hibernateJpamodelgen"]

    // Smallrye Config
    implementation libraries["smallryeConfig"]
    implementation libraries["tomcatAnnotations"]

    // Use wildcard because this could be called jss4.jar or jss.jar
    // (depending on if we are before Fedora35/RHEL9 or after)
    providedCompile fileTree(dir: '/usr/lib64/jss', include: '*.jar')
    providedCompile libraries["javaxServlet"]

    // DB Drivers
    runtimeOnly libraries["postgresql"]
    runtimeOnly libraries["mariadb"]

    testRuntimeOnly libraries["hsqldb"]
    testRuntimeOnly libraries["javaxEl"]

    // Core testing libraries
    // Junit 5
    testImplementation libraries["junitApi"]
    testImplementation libraries["junitParams"]
    testRuntimeOnly libraries["junitEngine"]

    testImplementation libraries["hamcrest"]
    testImplementation libraries["mockitoJunit"]
    testImplementation libraries["liquibaseSlf4j"]
    testImplementation libraries["assertj"]

    // OTEL
    implementation libraries["otelAnnotation"]
}

// Copy the resources to the main classes directory so that the
// persistence context is in the the same classpath entry for
// Hibernate annotation based discovery.
sourceSets.main.output.resourcesDir = new File(buildDir, "classes/java/main")

compileJava.dependsOn(processResources)

// Add the openapi generated classes to the main java source sets to compile in the generated interfaces
sourceSets {
    main.java.srcDir "${buildDir}/generated/api/src/gen/java"
}

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

gradleLint {
    rules = ["dependency-parentheses"]
    // Turn these on selectively.  They are a little too sensitive to leave on all the time,
    // but they provide useful information when run occasionally.
    // rules = ["dependency-parentheses", "unused-exclude-by-dep"]
    // criticalRules = ["unused-dependency"]
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = "UTF-8"
    // options.compilerArgs << "-Xlint:unchecked"
    // options.compilerArgs << "-Xlint:deprecation"
    // options.compilerArgs.addAll(['--release', '8'])
}

repositories {
    mavenCentral()

    maven { url "https://repo.jenkins-ci.org/public/" }
    maven { url "https://repository.jboss.org/nexus/content/groups/public/" }
}

openApiGenerate {
    generatorName = "jaxrs-spec"
    inputSpec = api_spec_path
    configFile = config_file
    outputDir = "$buildDir/generated/api"
    configOptions = [
            interfaceOnly: 'true',
            dateLibrary  : "java8",
            useTags      : "true"
    ]
    templateDir = "$rootDir/buildSrc/src/main/resources/templates"
}

openApiValidate {
    inputSpec = api_spec_path
}

tasks.register('generateApiDocs', GenerateTask) {
    generatorName = "html"
    inputSpec = api_spec_path
    outputDir = "$buildDir/docs"
    generateApiDocumentation = true
    generateModelDocumentation = true
    generateModelTests = false
    generateApiTests = false
    withXml = false
}

tasks.register('generateOpenApiJson', GenerateTask) {
    generatorName = "openapi"
    inputSpec = api_spec_path
    outputDir = "$buildDir/generated/json"
    generateApiDocumentation = true
    generateModelDocumentation = true
    generateModelTests = false
    generateApiTests = false
    withXml = false
}

//Update the compileJava & processResourcesTasks depend on the openapi generation so that the generated classes
//can be used during compilation.
compileJava.dependsOn tasks.openApiGenerate
processResources.dependsOn tasks.generateOpenApiJson

gettext {
    keys_project_dir = "${project.rootDir}/"
}

msgfmt {
    resource "org.candlepin.common.i18n.Messages"
}

test {
    debugOptions {
        host = '*'
    }

    useJUnitPlatform()

    // Sometimes causes out of memory on vagrant
    maxHeapSize = "2g"
    jvmArgs = [
            // We need to load the native jss lib (either libjss4.so or libjss.so) from this directory
            '-Djava.library.path=/usr/lib64/jss',
            '-XX:+HeapDumpOnOutOfMemoryError'
    ]

}

jacocoTestReport {
    dependsOn test

    reports {
        csv.required = false
        html.required = false
        xml.required = true
    }

    doLast {
        println "Generated unit test coverage report at $buildDir/reports/jacoco/test/jacocoTestReport.xml"
    }
}

// User-friendly alias for jacocoTestReport task
tasks.register("coverage") {
    dependsOn jacocoTestReport
}

project.tasks["sonar"].dependsOn "coverage"
sonar {
    properties {
        property "sonar.sourceEncoding", "Utf-8"
        property "sonar.projectKey", "candlepin_candlepin"
        property "sonar.organization", "candlepin"
        property "sonar.host.url", "https://sonarcloud.io"
    }
}

wrapper {
    distributionType = Wrapper.DistributionType.BIN
}

clean.doFirst {
    delete "${rootDir}/buildSrc/build"
    // Maven clean up
    delete "${rootDir}/src/main/webapp/docs/candlepin-api-spec.yaml"
    delete "${rootDir}/target"
}

// substitute the version & release in the version.properties used by the status resource at runtime
processResources {
    from("src/main/resources") {
        duplicatesStrategy = "include"
        include "version.properties"
        expand([version: project.getVersion(), release: project.findProperty("release")])
    }
}

// A task to generate the the candlepin config file for use in etc or other locations.
tasks.register('generateConfig') {
    dependsOn ":processResources"
    def template = file("$projectDir/config/candlepin/candlepin.conf.template")
    def targetFile = file("$buildDir/candlepin.conf")
    doLast {
        def defaults = [candlepin: project.ext.properties]
        def binding = [candlepin: defaults['candlepin']]

        try {
            def custom = new Yaml().load(new File("$projectDir/custom.yaml").newInputStream())
            // Overwrite the defaults with the values from custom.yaml
            // We have to use the key 'candlepin' instead of 'candlepin.conf' since the dot in the
            // key name would otherwise be interpreted as a dereference in the template.
            if (custom && custom['candlepin.conf']) {
                binding['candlepin'] << custom['candlepin.conf']
            }
        }
        catch (FileNotFoundException e) {
            println "No custom.yaml found.  Using defaults."
        }

        // change contents via cli options
        // change file contents
        def tmp = new GStringTemplateEngine()
                .createTemplate(template)
                .make(binding)
        targetFile.write(tmp.toString(), "UTF-8")
    }
}
assemble.dependsOn(generateConfig)

// task to generate candlepin-api jar that Hosted adapters build against
// invoked as `./gradlew apiJar`
tasks.register('apiJar', Jar) {
    archiveBaseName = 'candlepin-api'
    from sourceSets.main.output
    includes = [
            'auth',
            'config',
            'controller',
            'exceptions',
            'jackson',
            'model',
            'pki',
            'resteasy',
            'service',
            'util'
    ].collect { "/org/candlepin/${it}/" }
    duplicatesStrategy = 'exclude'
}

war {
    // This is a bit wonky and has potential to miss stuff, but we don't really have a much nicer
    // way of doing this, outside the real correct answer of converting them to subprojects like
    // they probably should be.
    if (project.hasProperty('test_extensions')) {
        List<String> testexts = test_extensions.tokenize(',');

        // If we've defined one or more test extensions, selectively exclude subpackages that are
        // not in the list of test extensions
        String testExtRootPath = "${buildDir}/classes/java/main/org/candlepin/testext/";
        File[] packages = new File(testExtRootPath)
            .listFiles((FileFilter) File::isDirectory);

        packages.each { pkg ->
            if (!testexts.contains(pkg.getName())) {
                rootSpec.exclude("**/testext/${pkg.getName()}/**");
            }
            else {
                println("Including test extension: ${pkg.getName()}")
            }
        }
    }
    else {
        // Building with no test extensions; exclude the whole package
        rootSpec.exclude("**/testext/**");
    }

    manifest {
        attributes(
            "Implementation-Title": "The Candlepin Project",
            "Copyright": "Red Hat, Inc. 2009-" + new Date().format("y")
        )
    }

    // Copy the license file into place in the final manifest
    from(projectDir) {
        include "LICENSE"
        into("META-INF")
    }

    from("./api") {
        include "candlepin-api-spec.yaml"
        into("docs")
    }
    from("$buildDir/generated/api/src/main/openapi") {
        include "openapi.yaml"
        into("WEB-INF/classes")
    }
    from("$buildDir/generated/json") {
        include "openapi.json"
        into("WEB-INF/classes")
    }
}

publishing {
    publications {
        // Publish the candlepin war
        warArtifact(MavenPublication) {
            from components.web

            groupId 'org.candlepin'
            artifactId 'candlepin'
        }

        // Publish the candlepin-api jar
        jarArtifact(MavenPublication) {
            artifact tasks.apiJar

            groupId = 'org.candlepin'
            artifactId = 'candlepin-api'
        }
    }
}
