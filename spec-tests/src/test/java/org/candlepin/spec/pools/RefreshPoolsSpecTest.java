/*
 * Copyright (c) 2009 - 2025 Red Hat, Inc.
 *
 * This software is licensed to you under the GNU General Public License,
 * version 2 (GPLv2). There is NO WARRANTY for this software, express or
 * implied, including the implied warranties of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
 * along with this software; if not, see
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
 *
 * Red Hat trademarks are not licensed under GPLv2. No permission is
 * granted to use or replicate Red Hat trademarks that are incorporated
 * in this software or its documentation.
 */
package org.candlepin.spec.pools;

import static java.lang.Thread.sleep;
import static org.assertj.core.api.Assertions.as;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.entry;
import static org.assertj.core.api.Assertions.from;
import static org.assertj.core.api.InstanceOfAssertFactories.collection;
import static org.candlepin.spec.bootstrap.assertions.JobStatusAssert.assertThatJob;
import static org.candlepin.spec.bootstrap.assertions.StatusCodeAssertions.assertNotFound;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;

import org.candlepin.dto.api.client.v1.AsyncJobStatusDTO;
import org.candlepin.dto.api.client.v1.BrandingDTO;
import org.candlepin.dto.api.client.v1.CertificateDTO;
import org.candlepin.dto.api.client.v1.CertificateSerialDTO;
import org.candlepin.dto.api.client.v1.ConsumerDTO;
import org.candlepin.dto.api.client.v1.ContentDTO;
import org.candlepin.dto.api.client.v1.EntitlementDTO;
import org.candlepin.dto.api.client.v1.OwnerDTO;
import org.candlepin.dto.api.client.v1.PoolDTO;
import org.candlepin.dto.api.client.v1.ProductDTO;
import org.candlepin.dto.api.client.v1.ProvidedProductDTO;
import org.candlepin.dto.api.client.v1.SubscriptionDTO;
import org.candlepin.spec.bootstrap.assertions.CandlepinMode;
import org.candlepin.spec.bootstrap.assertions.OnlyInHosted;
import org.candlepin.spec.bootstrap.client.ApiClient;
import org.candlepin.spec.bootstrap.client.ApiClients;
import org.candlepin.spec.bootstrap.client.SpecTest;
import org.candlepin.spec.bootstrap.data.builder.Branding;
import org.candlepin.spec.bootstrap.data.builder.ConsumerTypes;
import org.candlepin.spec.bootstrap.data.builder.Consumers;
import org.candlepin.spec.bootstrap.data.builder.Contents;
import org.candlepin.spec.bootstrap.data.builder.Owners;
import org.candlepin.spec.bootstrap.data.builder.ProductAttributes;
import org.candlepin.spec.bootstrap.data.builder.Products;
import org.candlepin.spec.bootstrap.data.builder.Subscriptions;
import org.candlepin.spec.bootstrap.data.util.CertificateUtil;
import org.candlepin.spec.bootstrap.data.util.StringUtil;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import tools.jackson.databind.JsonNode;

import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;


@SpecTest
public class RefreshPoolsSpecTest {
    private static final String POOL_REFRESH_RESULT_PREFIX = "Pools refreshed for owner: ";

    private ApiClient adminClient;
    private OwnerDTO owner;
    private String ownerKey;

    @BeforeEach
    public void setup() {
        adminClient = ApiClients.admin();
        owner = adminClient.owners().createOwner(Owners.random());
        ownerKey = owner.getKey();
    }

    @Test
    @OnlyInHosted
    public void shouldCreateValidJob() {
        AsyncJobStatusDTO status = refreshPools(adminClient, ownerKey);
        assertEquals(POOL_REFRESH_RESULT_PREFIX + owner.getDisplayName(), status.getResultData());
    }

    @Test
    public void shouldContainTheProperValueWhenOwnerIsAutoGenerated() {
        String expectedKey = StringUtil.random("autoKey-");
        AsyncJobStatusDTO status = refreshPools(adminClient, expectedKey);

        if (CandlepinMode.isHosted()) {
            assertEquals(POOL_REFRESH_RESULT_PREFIX + expectedKey, status.getResultData());
        }
        else {
            assertNull(status);
        }

        OwnerDTO owner = adminClient.owners().getOwner(expectedKey);
        assertNotNull(owner);
        assertEquals(expectedKey, owner.getDisplayName());
        assertEquals(Owners.SCA_ACCESS_MODE, owner.getContentAccessMode());
    }

    @Test
    @OnlyInHosted
    public void shouldCreateTheCorrectNumberOfPools() {
        int expectedSubscriptionCount = 6;
        Set<String> expectedSubIds = new HashSet<>();
        for (int i = 0; i < expectedSubscriptionCount; i++) {
            ProductDTO prod = adminClient.hosted().createProduct(Products.random());
            SubscriptionDTO sub = adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));
            expectedSubIds.add(sub.getId());
        }

        refreshPools(adminClient, ownerKey);

        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools)
            .hasSize(expectedSubscriptionCount)
            .map(PoolDTO::getSubscriptionId)
            .isNotNull()
            .containsExactlyInAnyOrderElementsOf(expectedSubIds);
    }

    @Test
    @OnlyInHosted
    public void shouldDetectChangesInProviderProducts() {
        ProductDTO prod1 = adminClient.hosted().createProduct(Products.random());
        ProductDTO prod2 = adminClient.hosted().createProduct(Products.random());
        ProductDTO providerProduct = Products.random();
        providerProduct.setProvidedProducts(Set.of(prod1, prod2));
        providerProduct = adminClient.hosted().createProduct(providerProduct);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, providerProduct));

        refreshPools(adminClient, ownerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        PoolDTO actualPool = pools.get(0);
        Set<String> expectedProvProdIds = Set.of(prod1.getId(), prod2.getId());
        assertThat(actualPool.getProvidedProducts())
            .isNotNull()
            .map(ProvidedProductDTO::getProductId)
            .hasSameSizeAs(expectedProvProdIds)
            .hasSameElementsAs(expectedProvProdIds);

        // Remove the old provided products and add a new one...
        ProductDTO prod3 = adminClient.hosted().createProduct(Products.random());
        providerProduct.setProvidedProducts(Set.of(prod3));
        providerProduct = adminClient.hosted().updateProduct(providerProduct.getId(), providerProduct);

        refreshPools(adminClient, ownerKey);
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools)
            .isNotNull()
            .hasSize(1);

        assertThat(pools.get(0).getProvidedProducts())
            .isNotNull()
            .singleElement()
            .returns(prod3.getId(), from(ProvidedProductDTO::getProductId));
    }

    @Test
    @OnlyInHosted
    public void shouldDetectChangesInBranding() {
        BrandingDTO brand1 = Branding.random();
        brand1.setProductId(StringUtil.random("prod-"));
        ProductDTO product = adminClient.hosted()
            .createProduct(Products.random().branding(Set.of(brand1)));
        adminClient.hosted().createSubscription(Subscriptions.random(owner, product));

        refreshPools(adminClient, ownerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());
        assertEquals(1, pools.get(0).getBranding().size());
        compareBrandings(brand1, pools.get(0).getBranding().stream().iterator().next());

        // Check the branding set is visible on the product.
        ProductDTO actualProduct = adminClient.ownerProducts().getProductById(ownerKey, product.getId());
        assertNotNull(actualProduct);
        assertEquals(1, actualProduct.getBranding().size());
        compareBrandings(brand1, actualProduct.getBranding().stream().iterator().next());

        // Add an additional branding to the upstream product than the one we had initially...
        BrandingDTO brand2 = Branding.random();
        brand2.setProductId(StringUtil.random("prod-"));
        Set<BrandingDTO> expectedBranding = Set.of(brand1, brand2);
        product.setBranding(expectedBranding);
        adminClient.hosted().updateProduct(product.getId(), product);

        refreshPools(adminClient, ownerKey);
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());
        compareBrandings(expectedBranding, pools.get(0).getBranding());

        // Check the updated branding set is visible on the product.
        actualProduct = adminClient.ownerProducts().getProductById(ownerKey, product.getId());
        assertNotNull(actualProduct);
        Set<BrandingDTO> actualBranding = actualProduct.getBranding();
        compareBrandings(expectedBranding, actualBranding);
    }

    @Test
    @OnlyInHosted
    public void shouldDeleteExpiredSubscriptionPoolsAndEntitlements() {
        ProductDTO product = adminClient.hosted().createProduct(Products.random());
        SubscriptionDTO sub = adminClient.hosted().createSubscription(Subscriptions.random(owner, product));

        refreshPools(adminClient, ownerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());
        PoolDTO pool = pools.get(0);

        ConsumerDTO user = Consumers.random(owner, ConsumerTypes.System);
        user.setUsername("admin");
        user = adminClient.consumers().createConsumer(user, "admin",
        owner.getKey(), null, true);
        ApiClient consumerClient = ApiClients.ssl(user);

        JsonNode ents = consumerClient.consumers().bindPool(user.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());

        user = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(1, user.getEntitlementCount());

        // Update subscription such that it's expired, then refresh. The entitlements should be removed.
        sub.setStartDate(OffsetDateTime.now().minusDays(20L));
        sub.setEndDate(OffsetDateTime.now().minusDays(10L));
        sub = adminClient.hosted().updateSubscription(sub.getId(), sub);

        refreshPools(adminClient, ownerKey);
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(0, pools.size());

        user = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(0, user.getEntitlementCount());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntitlements() {
        ProductDTO prod1 = adminClient.hosted().createProduct(Products.random());
        ProductDTO prod2 = adminClient.hosted().createProduct(Products.random());
        SubscriptionDTO sub = adminClient.hosted().createSubscription(Subscriptions.random(owner, prod1));

        refreshPools(adminClient, ownerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());
        PoolDTO pool = pools.get(0);

        ConsumerDTO user = Consumers.random(owner, ConsumerTypes.System);
        user.setUsername("admin");
        user = adminClient.consumers()
            .createConsumer(user, "admin", owner.getKey(), null, true);
        ApiClient consumerClient = ApiClients.ssl(user);

        JsonNode root = consumerClient.consumers().bindPool(user.getUuid(), pool.getId(), 1);
        assertEquals(1, root.size());
        EntitlementDTO createdEnt = ApiClient.MAPPER.convertValue(root.get(0), EntitlementDTO.class);

        ConsumerDTO consumer = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(1, consumer.getEntitlementCount());

        CertificateDTO initialCert = createdEnt.getCertificates().stream().iterator().next();
        CertificateSerialDTO initialSerial = initialCert.getSerial();

        // Update the subscription's product to trigger an entitlement regeneration
        sub.setProduct(prod2);
        adminClient.hosted().updateSubscription(sub.getId(), sub);

        refreshPools(adminClient, ownerKey);

        consumer = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(1, consumer.getEntitlementCount());

        EntitlementDTO updatedEnt = adminClient.entitlements().getEntitlement(createdEnt.getId());
        assertNotNull(updatedEnt);
        CertificateDTO updatedCert = updatedEnt.getCertificates().stream().iterator().next();
        CertificateSerialDTO updatedSerial = updatedCert.getSerial();

        assertNotEquals(initialCert, updatedCert);
        assertNotEquals(initialSerial, updatedSerial);
    }

    @Test
    @OnlyInHosted
    public void shouldHandleDerivedProductsBeingRemoved() {
        ProductDTO derivedEngProduct = adminClient.hosted().createProduct(Products.randomEng());
        ProductDTO derivedProduct = Products.random();
        derivedProduct.providedProducts(Set.of(derivedEngProduct));
        derivedProduct.setAttributes(List.of(ProductAttributes.Cores.withValue("2"),
            ProductAttributes.Sockets.withValue("4")));
        derivedProduct = adminClient.hosted().createProduct(derivedProduct);

        ProductDTO dataCenterProduct = Products.random();
        dataCenterProduct.setAttributes(List.of(ProductAttributes.VirtualLimit.withValue("unlimited"),
            ProductAttributes.StackingId.withValue("stackme"),
            ProductAttributes.Sockets.withValue("2"),
            ProductAttributes.MultiEntitlement.withValue("yes")));
        dataCenterProduct.setDerivedProduct(derivedProduct);
        dataCenterProduct = adminClient.hosted().createProduct(dataCenterProduct);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, dataCenterProduct));

        refreshPools(adminClient, ownerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());

        // We're expecting the base pool + a virt-only bonus pool for guests
        assertThat(pools)
            .hasSize(2)
            .map(PoolDTO::getProductId)
            .containsExactlyInAnyOrder(dataCenterProduct.getId(), derivedProduct.getId());

        dataCenterProduct.setDerivedProduct(null);
        adminClient.hosted().updateProduct(dataCenterProduct.getId(), dataCenterProduct, false);

        refreshPools(adminClient, ownerKey);
        pools = adminClient.pools()
            .listPools(owner.getId(), null, dataCenterProduct.getId(), null, null, null, null, null, null);

        assertThat(pools)
            .hasSize(2)
            .map(PoolDTO::getProductId)
            .containsOnly(dataCenterProduct.getId());

        pools.stream()
            .forEach(pool -> assertEquals(0, pool.getDerivedProvidedProducts().size()));
    }

    @Test
    @OnlyInHosted
    public void shouldMigrateSubscriptions() {
        OwnerDTO owner2 = adminClient.owners().createOwner(Owners.random());
        ProductDTO prod = adminClient.hosted().createProduct(Products.random());
        SubscriptionDTO sub = adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        refreshPools(adminClient, owner2.getKey());

        assertEquals(1, adminClient.pools().listPoolsByOwner(owner.getId()).size());
        assertEquals(0, adminClient.pools().listPoolsByOwner(owner2.getId()).size());

        // Update sub to be owned by the second owner
        sub.setOwner(Owners.toNested(owner2));
        adminClient.hosted().updateSubscription(sub.getId(), sub);

        refreshPools(adminClient, owner.getKey());
        refreshPools(adminClient, owner2.getKey());

        assertEquals(0, adminClient.pools().listPoolsByOwner(owner.getId()).size());
        assertEquals(1, adminClient.pools().listPoolsByOwner(owner2.getId()).size());
    }

    @Test
    @OnlyInHosted
    public void shouldChangeAttributesAndRevokeEntitlementsAtTheSameTime() {
        ProductDTO prod = Products.random()
            .addAttributesItem(ProductAttributes.MultiEntitlement.withValue("yes"));
        prod = adminClient.hosted().createProduct(prod);
        SubscriptionDTO sub = adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        ConsumerDTO user = Consumers.random(owner, ConsumerTypes.System);
        user.setUsername("admin");
        user = adminClient.consumers().createConsumer(user, "admin",
        owner.getKey(), null, true);
        ApiClient consumerClient = ApiClients.ssl(user);

        refreshPools(adminClient, ownerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        // We'll consume quantity 2, later we will reduce the pool to 1 forcing revokation of this entitlement
        JsonNode root = consumerClient.consumers().bindPool(user.getUuid(), pools.get(0).getId(), 2);
        assertEquals(1, root.size());

        // Is this correct? Should it be just one?
        user = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(2, user.getEntitlementCount());

        // Add a new attribute to the product
        String expectedNewAttName = "arch";
        prod.addAttributesItem(ProductAttributes.Arch.withValue(expectedNewAttName));

        prod = adminClient.hosted().updateProduct(prod.getId(), prod);
        // ...and reduce the quantity available on the subscription
        sub.quantity(1L);
        sub.product(prod);
        sub = adminClient.hosted().updateSubscription(sub.getId(), sub);

        refreshPools(adminClient, ownerKey);
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        assertThat(pools.get(0).getProductAttributes())
            .hasSize(2)
            .containsExactlyInAnyOrderElementsOf(prod.getAttributes());

        // Verify that the entitlement was revoked
        user = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(0, user.getEntitlementCount());

        assertNotFound(() -> adminClient.entitlements().getEntitlement(root.get(0).get("id").asText()));
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntitlementsWhenContentForAnEntitledPoolChanges() {
        ContentDTO content = adminClient.hosted().createContent(Contents.random());
        ProductDTO prod = adminClient.hosted().createProduct(Products.random());
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, ownerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        // Verify the content exists in its initial state
        ContentDTO actualContent = adminClient.ownerContent().getContentById(ownerKey, content.getId());
        assertNotNull(actualContent);
        assertEquals(content.getId(), actualContent.getId());
        assertEquals(content.getType(), actualContent.getType());
        assertEquals(content.getName(), actualContent.getName());
        assertEquals(content.getLabel(), actualContent.getLabel());
        assertEquals(content.getVendor(), actualContent.getVendor());

        // Consume the pool so we have an entitlement
        ConsumerDTO user = Consumers.random(owner, ConsumerTypes.System);
        user.setUsername("admin");
        user = adminClient.consumers().createConsumer(user, "admin",
        owner.getKey(), null, true);
        ApiClient consumerClient = ApiClients.ssl(user);

        JsonNode ents = consumerClient.consumers().bindPool(user.getUuid(), pools.get(0).getId(), 1);
        assertEquals(1, ents.size());
        JsonNode ent = ents.get(0);
        user = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(1, user.getEntitlementCount());
        String entId = ent.get("id").asText();
        JsonNode cert = ent.get("certificates").get(0);
        CertificateDTO originalCert = ApiClient.MAPPER.convertValue(cert, CertificateDTO.class);
        CertificateSerialDTO originalSerial = originalCert.getSerial();

        // Modify the content for this product/sub
        String expectedLabelUpdated = "updated-label";
        content.setLabel(expectedLabelUpdated);
        content = adminClient.hosted().updateContent(content.getId(), content);

        refreshPools(adminClient, ownerKey);
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        // Verify the content change has been pulled down
        content = adminClient.ownerContent().getContentById(ownerKey, content.getId());
        assertEquals(expectedLabelUpdated, content.getLabel());

        // Verify the entitlement cert has changed as a result
        EntitlementDTO updatedEnt = adminClient.entitlements().getEntitlement(entId);
        assertEquals(1, updatedEnt.getCertificates().size());
        CertificateDTO updatedCert = updatedEnt.getCertificates().stream().iterator().next();
        CertificateSerialDTO updatedSerial = updatedCert.getSerial();

        assertNotEquals(originalSerial, updatedSerial);
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateSCACertWhenContentForAnOrgChanges() {
        OwnerDTO scaOwner = adminClient.owners().createOwner(Owners.randomSca());
        String scaOwnerKey = scaOwner.getKey();

        ContentDTO content = Contents.random().contentUrl(StringUtil.random("/url-"));
        content = adminClient.hosted().createContent(content);
        ProductDTO prod = adminClient.hosted().createProduct(Products.random());
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        adminClient.hosted().createSubscription(Subscriptions.random(scaOwner, prod));

        refreshPools(adminClient, scaOwnerKey);
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(scaOwner.getId());
        assertEquals(1, pools.size());

        // Verify the content exists in its initial state
        ContentDTO actualContent = adminClient.ownerContent().getContentById(scaOwnerKey, content.getId());
        assertNotNull(actualContent);
        assertEquals(content.getLabel(), actualContent.getLabel());
        assertEquals(content.getContentUrl(), actualContent.getContentUrl());

        // Register a consumer and check the SCA cert contains the correct content data
        ConsumerDTO user = Consumers.random(scaOwner, ConsumerTypes.System);
        user.setUsername("admin");
        user = adminClient.consumers().createConsumer(user, "admin",
        scaOwnerKey, null, true);
        ApiClient consumerClient = ApiClients.ssl(user);

        List<JsonNode> certificates = consumerClient.consumers().exportCertificates(user.getUuid(), null);
        assertEquals(1, certificates.size());
        JsonNode body = certificates.get(0);
        Map<String, List<String>> prodIdToContentIds = CertificateUtil.toProductContentIdMap(body);
        assertThat(prodIdToContentIds)
            .isNotNull()
            .hasSize(1)
            .containsOnlyKeys("content_access");

        assertThat(prodIdToContentIds.get("content_access"))
            .isNotNull()
            .singleElement()
            .isEqualTo(content.getId());

        // Modify the content for this product/sub
        String updatedUrl = "http://www.updated-url.com";
        content.setContentUrl(updatedUrl);
        ContentDTO updatedContent = adminClient.hosted().updateContent(content.getId(), content);

        refreshPools(adminClient, scaOwner.getKey());
        pools = adminClient.pools().listPoolsByOwner(scaOwner.getId());
        assertEquals(1, pools.size());

        // Verify the content change has been pulled down
        actualContent = adminClient.ownerContent().getContentById(scaOwnerKey, updatedContent.getId());
        assertNotNull(actualContent);
        assertEquals(updatedContent.getLabel(), actualContent.getLabel());
        assertEquals(updatedContent.getContentUrl(), actualContent.getContentUrl());

        // Verify the SCA cert has changed as a result
        certificates = consumerClient.consumers().exportCertificates(user.getUuid(), null);
        assertEquals(1, certificates.size());
        body = certificates.get(0);
        prodIdToContentIds = CertificateUtil.toProductContentIdMap(body);
        assertThat(prodIdToContentIds)
            .isNotNull()
            .hasSize(1)
            .containsOnlyKeys("content_access");

        assertThat(prodIdToContentIds.get("content_access"))
            .isNotNull()
            .singleElement()
            .isEqualTo(updatedContent.getId());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntitlementsWhenProductsForAnEntitledPoolChanges() {
        ProductDTO prod = createProductWithContent();
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        // Verify the product exists in its initial state
        ProductDTO actualProd = adminClient.ownerProducts().getProductById(ownerKey, prod.getId());
        assertEquals(prod.getId(), actualProd.getId());
        assertEquals(prod.getName(), actualProd.getName());

        // Consume the pool so we have an entitlement
        ConsumerDTO user = Consumers.random(owner, ConsumerTypes.System);
        user.setUsername("admin");
        user = adminClient.consumers().createConsumer(user, "admin",
        ownerKey, null, true);
        ApiClient consumerClient = ApiClients.ssl(user);

        JsonNode ents = consumerClient.consumers().bindPool(user.getUuid(), pools.get(0).getId(), 1);
        assertNotNull(ents);
        assertEquals(1, ents.size());
        user = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(1, user.getEntitlementCount());

        JsonNode entCert = ents.get(0).get("certificates").get(0);
        JsonNode entSerial = entCert.get("serial").get("serial");

        // Modify the product for this sub
        String updatedName = StringUtil.random("update-");
        prod.setName(updatedName);
        adminClient.hosted().updateProduct(prod.getId(), prod);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        // Verify the product change has been pulled down
        actualProd = adminClient.ownerProducts().getProductById(ownerKey, prod.getId());
        assertNotNull(actualProd);
        assertEquals(updatedName, actualProd.getName());

        // Verify the entitlement cert has changed as a result
        EntitlementDTO updatedEnt = adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText());
        assertNotNull(updatedEnt);
        assertEquals(1, updatedEnt.getCertificates().size());
        CertificateDTO updatedCert = updatedEnt.getCertificates().stream().iterator().next();
        assertNotEquals(entSerial.asLong(), updatedCert.getSerial().getSerial());
    }

    @Test
    @OnlyInHosted
    @SuppressWarnings("methodlength")
    public void shouldRegenEntitlementsWhenRequiredProductsChanges() throws Exception {
        ProductDTO engProd1 = adminClient.hosted().createProduct(Products.randomEng());
        ProductDTO engProd2 = adminClient.hosted().createProduct(Products.randomEng());
        ContentDTO content1 = adminClient.hosted().createContent(Contents.random());
        ContentDTO content2 = adminClient.hosted().createContent(Contents.random());
        ContentDTO content3 = adminClient.hosted().createContent(Contents.random());

        engProd1 = adminClient.hosted().addContentToProduct(engProd1.getId(), content1.getId(), true);
        engProd2 = adminClient.hosted().addContentToProduct(engProd2.getId(), content2.getId(), true);
        engProd2 = adminClient.hosted().addContentToProduct(engProd2.getId(), content3.getId(), true);

        ProductDTO skuProd1 = Products.random().providedProducts(Set.of(engProd1));
        ProductDTO skuProd2 = Products.random().providedProducts(Set.of(engProd2));
        skuProd1 = adminClient.hosted().createProduct(skuProd1);
        skuProd2 = adminClient.hosted().createProduct(skuProd2);
        SubscriptionDTO sub1 = adminClient.hosted().createSubscription(Subscriptions.random(owner, skuProd1));
        SubscriptionDTO sub2 = adminClient.hosted().createSubscription(Subscriptions.random(owner, skuProd2));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).map(PoolDTO::getSubscriptionId)
            .containsExactlyInAnyOrder(sub1.getId(), sub2.getId());

        PoolDTO pool1 = pools.get(0).getSubscriptionId().equals(sub1.getId()) ? pools.get(0) : pools.get(1);
        PoolDTO pool2 = pools.get(0).getSubscriptionId().equals(sub2.getId()) ? pools.get(0) : pools.get(1);

        List<String> pids = Stream.of(engProd1, engProd2, skuProd1, skuProd2)
            .map(ProductDTO::getId)
            .toList();

        List<ProductDTO> actualProducts = adminClient.ownerProducts()
            .getProductsByOwner(ownerKey, pids, null, null, "include");
        assertThat(actualProducts)
            .map(ProductDTO::getId)
            .containsAll(pids);

        List<String> cids = Stream.of(content1, content2, content3)
            .map(ContentDTO::getId)
            .toList();

        List<ContentDTO> actualContent = adminClient.ownerContent()
            .getContentsByOwner(ownerKey, cids, List.of(), null, null);
        assertThat(actualContent)
            .map(ContentDTO::getId)
            .containsAll(cids);

        // Consume both pools
        ConsumerDTO user = adminClient.consumers().createConsumer(Consumers
            .random(owner, ConsumerTypes.System), "admin", ownerKey, null, true);
        ApiClient consumerClient = ApiClients.ssl(user);

        JsonNode ents = consumerClient.consumers().bindPool(user.getUuid(), pool1.getId(), 1);
        assertEquals(1, ents.size());
        JsonNode bindEnt1 = ents.get(0);
        ents = consumerClient.consumers().bindPool(user.getUuid(), pool2.getId(), 1);
        assertEquals(1, ents.size());
        JsonNode bindEnt2 = ents.get(0);

        assertThat(adminClient.consumers().listEntitlements(user.getUuid()))
            .map(EntitlementDTO::getId)
            .containsExactlyInAnyOrder(bindEnt1.get("id").asText(), bindEnt2.get("id").asText());

        // Verify the entitlements contains the products and content
        List<String> certs = ApiClient.MAPPER.convertValue(bindEnt1.get("certificates"), List.class);
        List<JsonNode> bindEnt1Certs = CertificateUtil
            .extractEntitlementCertificatesFromPayload(certs, ApiClient.MAPPER);
        certs = ApiClient.MAPPER.convertValue(bindEnt2.get("certificates"), List.class);
        List<JsonNode> bindEnt2Certs = CertificateUtil
            .extractEntitlementCertificatesFromPayload(certs, ApiClient.MAPPER);
        assertEquals(1, bindEnt1Certs.size());
        assertEquals(1, bindEnt2Certs.size());

        assertThat(CertificateUtil.toProductContentIdMap(bindEnt1Certs.get(0)))
            .isNotNull()
            .containsExactly(entry(engProd1.getId(), List.of(content1.getId())));

        assertThat(CertificateUtil.toProductContentIdMap(bindEnt2Certs.get(0)))
            .isNotNull()
            .containsOnlyKeys(engProd2.getId())
            .extractingByKey(engProd2.getId(), as(collection(String.class)))
            .isNotNull()
            .containsExactlyInAnyOrder(content2.getId(), content3.getId());

        // Add a dependent product to content2 for a product the consumer is entitled to
        content2.setModifiedProductIds(Set.of(engProd1.getId()));
        adminClient.hosted().updateContent(content2.getId(), content2);

        refreshPools(adminClient, owner.getKey());

        // Verify the content change has been pulled down
        assertEquals(Set.of(engProd1.getId()), adminClient.ownerContent()
            .getContentById(ownerKey, content2.getId()).getModifiedProductIds());

        // Verify the entitlement has been regenerated
        EntitlementDTO updatedEnt = adminClient.entitlements().getEntitlement(bindEnt2.get("id").asText());
        assertEquals(1, updatedEnt.getCertificates().size());
        CertificateDTO cert = updatedEnt.getCertificates().stream().iterator().next();
        assertNotEquals(bindEnt2.get("certificates").get(0).path("serial").path("serial").asLong(), cert
            .getSerial().getSerial());

        // Verify the content path is still present in the entitlement
        assertEquals(1, updatedEnt.getCertificates().size());
        CertificateDTO updatedEntCert = updatedEnt.getCertificates().stream().iterator().next();
        JsonNode updatedCert = CertificateUtil
            .decodeAndUncompressCertificate(updatedEntCert.getCert(), ApiClient.MAPPER);

        assertThat(CertificateUtil.toProductContentIdMap(updatedCert))
            .isNotNull()
            .containsOnlyKeys(engProd2.getId())
            .extractingByKey(engProd2.getId(), as(collection(String.class)))
            .isNotNull()
            .containsExactlyInAnyOrder(content2.getId(), content3.getId());

        // Add a dependent product to content3 for a product the consumer is NOT entitled to
        String unknownProdId = "unknown";
        content3.setModifiedProductIds(Set.of(unknownProdId));
        content3 = adminClient.hosted().updateContent(content3.getId(), content3);
        refreshPools(adminClient, owner.getKey());

        // Verify the content change has been pulled down
        assertEquals(Set.of(unknownProdId), adminClient.ownerContent()
            .getContentById(ownerKey, content3.getId()).getModifiedProductIds());

        // Verify the entitlement has been regenerated
        updatedEnt = adminClient.entitlements().getEntitlement(bindEnt2.get("id").asText());
        assertEquals(1, updatedEnt.getCertificates().size());
        cert = updatedEnt.getCertificates().stream().iterator().next();
        assertNotEquals(bindEnt2.get("certificates").get(0).path("serial").path("serial").asLong(), cert
            .getSerial().getSerial());

        // Verify the content path is still present in the entitlement
        updatedCert = CertificateUtil.decodeAndUncompressCertificate(cert.getCert(), ApiClient.MAPPER);

        assertThat(CertificateUtil.toProductContentIdMap(updatedCert))
            .isNotNull()
            .containsExactly(entry(engProd2.getId(), List.of(content2.getId())));
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntitlementsWhenBrandingForAProductOfAnEntitledPoolChanges()
        throws Exception {
        BrandingDTO brand = Branding.build(StringUtil.random("brand-"), StringUtil.random("name-"))
            .productId(StringUtil.random("prod-"));
        ProductDTO prod = adminClient.hosted().createProduct(Products.random().branding(Set.of(brand)));
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());
        PoolDTO pool = pools.get(0);

        // Verify the product exists in its initial state
        ProductDTO actualProd = adminClient.ownerProducts().getProductById(ownerKey, prod.getId());
        assertNotNull(actualProd);
        compareProducts(prod, actualProd);
        compareBrandings(prod.getBranding(), actualProd.getBranding());

        // Consume the pool so we have an entitlement
        ConsumerDTO user = Consumers.random(owner, ConsumerTypes.System);
        user.setUsername("admin");
        user = adminClient.consumers().createConsumer(user, "admin",
        ownerKey, null, true);
        ApiClient consumerClient = ApiClients.ssl(user);

        JsonNode ents = consumerClient.consumers().bindPool(user.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());
        JsonNode ent = ents.get(0);
        JsonNode cert = ent.get("certificates").get(0);
        JsonNode serial = cert.get("serial").get("serial");

        user = adminClient.consumers().getConsumer(user.getUuid());
        assertEquals(1, user.getEntitlementCount());

        // Update the name of the branding of the upstream product...
        brand.setName(StringUtil.random("brand-"));
        prod.setBranding(Set.of(brand));
        prod = adminClient.hosted().updateProduct(prod.getId(), prod);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        // Verify the branding change on the product has been pulled down
        actualProd = adminClient.ownerProducts().getProductById(ownerKey, prod.getId());
        assertNotNull(actualProd);
        compareProducts(prod, actualProd);
        compareBrandings(prod.getBranding(), actualProd.getBranding());

        // Verify the entitlement cert has changed as a result
        EntitlementDTO updatedEnt = adminClient.entitlements().getEntitlement(ent.get("id").asText());
        assertThat(updatedEnt.getCertificates())
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .extracting(CertificateSerialDTO::getSerial)
            .isNotEqualTo(serial.asLong());
    }

    @Test
    @OnlyInHosted
    public void shouldInvalidateEntitlementsWhenPoolQuantityIsReduced() throws Exception {
        ProductDTO prod = createProductWithContent();
        SubscriptionDTO sub = adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());
        assertEquals(sub.getQuantity(), pools.get(0).getQuantity());
        PoolDTO pool = pools.get(0);

        // Verify the product exists in its initial state
        ProductDTO fetchedProd = adminClient.ownerProducts().getProductById(ownerKey, prod.getId());
        compareProducts(prod, fetchedProd);

        // Consume the pool multiple times so we have entitlements to revoke
        for (int i = 0; i < sub.getQuantity(); i++) {
            ConsumerDTO user = Consumers.random(owner, ConsumerTypes.System);
            user.setUsername("admin");
            user = adminClient.consumers().createConsumer(user, "admin",
            owner.getKey(), null, true);
            ApiClient consumerClient = ApiClients.ssl(user);

            JsonNode entNode = consumerClient.consumers().bindPool(user.getUuid(), pool.getId(), 1);
            assertEquals(1, entNode.size());

            user = adminClient.consumers().getConsumer(user.getUuid());
            assertEquals(1, user.getEntitlementCount());
        }

        // Verify the entitlement count for this pool
        List<EntitlementDTO> ents = adminClient.pools().getPoolEntitlements(pool.getId());
        assertEquals(sub.getQuantity(), ents.size());

        // Modify the subscription upstream
        sub.setQuantity(1L);
        adminClient.hosted().updateSubscription(sub.getId(), sub);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());
        pool = pools.get(0);
        assertEquals(sub.getQuantity(), pool.getQuantity());

        // Verify the entitlement count has changed
        ents = adminClient.pools().getPoolEntitlements(pool.getId());
        assertEquals(1, ents.size());
    }

    @Test
    @OnlyInHosted
    public void shouldDeleteBonusPoolsWhenVirtLimitAttributeIsRemovedFromPrimaryPool() throws Exception {
        ContentDTO content = adminClient.hosted().createContent(Contents.random());
        ProductDTO prod = Products.random();
        prod.setAttributes(List.of(ProductAttributes.VirtualLimit.withValue("unlimited"),
            ProductAttributes.HostLimited.withValue("true")));
        prod = adminClient.hosted().createProduct(prod);
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        Long subQuantity = 5L;
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod).quantity(subQuantity));
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod).quantity(subQuantity));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        // 2 primary pool and 2 bonus pools
        assertEquals(4, pools.size());

        List<PoolDTO> primaryPools = pools.stream()
            .filter(pool -> pool.getType().equals("NORMAL"))
            .collect(Collectors.toList());
        assertThat(primaryPools)
            .hasSize(2)
            .map(PoolDTO::getQuantity)
            .containsOnly(subQuantity);

        List<PoolDTO> bonusPools = pools.stream()
            .filter(pool -> pool.getType().equals("UNMAPPED_GUEST"))
            .collect(Collectors.toList());
        assertThat(bonusPools)
            .hasSize(2)
            .map(PoolDTO::getQuantity)
            .containsOnly(-1L);

        ConsumerDTO guestUser = createGuestUser();
        ApiClient guestClient = ApiClients.ssl(guestUser);

        JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), bonusPools.get(0).getId(), 1);
        assertEquals(1, ents.size());

        // Verify the entitlement count for the two bonus pools
        List<EntitlementDTO> bonusPoolEnts = adminClient.pools()
            .getPoolEntitlements(bonusPools.get(0).getId());
        assertThat(bonusPoolEnts).hasSize(1);
        bonusPoolEnts = adminClient.pools().getPoolEntitlements(bonusPools.get(1).getId());
        assertThat(bonusPoolEnts).hasSize(0);

        // Modify the subscription upstream (remove the virt_limit attribute) & do another refresh
        prod.setAttributes(List.of(ProductAttributes.HostLimited.withValue("true")));
        prod = adminClient.hosted().updateProduct(prod.getId(), prod);

        refreshPools(adminClient, owner.getKey());

        // Verify that both bonus pools where deleted
        assertThat(adminClient.pools().listPoolsByOwner(owner.getId()))
            .hasSize(2)
            .map(PoolDTO::getType)
            .containsOnly("NORMAL");

        // Check the the entitlement from the deleted bonus pool was revoked
        assertThat(adminClient.consumers().getConsumer(guestUser.getUuid()))
            .isNotNull()
            .returns(0L, ConsumerDTO::getEntitlementCount);
    }

    @Test
    @OnlyInHosted
    public void shouldInvalidateBonusPoolEntsWhenPrimaryPoolQuantityIsReduced() throws Exception {
        ContentDTO content = adminClient.hosted().createContent(Contents.random());
        ProductDTO prod = Products.random();
        prod.setAttributes(List.of(ProductAttributes.VirtualLimit.withValue("1")));
        prod = adminClient.hosted().createProduct(prod);
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        Long subQuantity = 5L;
        SubscriptionDTO sub = adminClient.hosted()
            .createSubscription(Subscriptions.random(owner, prod).quantity(subQuantity));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        // primary pool and bonus pool
        assertThat(pools)
            .hasSize(2)
            .map(PoolDTO::getType)
            .containsExactlyInAnyOrder("NORMAL", "BONUS");
        assertThat(pools)
            .map(PoolDTO::getQuantity)
            .containsOnly(subQuantity);

        PoolDTO primaryPool = pools.get(0).getType().equals("NORMAL") ? pools.get(0) : pools.get(1);
        PoolDTO bonusPool = pools.get(0).getType().equals("BONUS") ? pools.get(0) : pools.get(1);

        // Verify the product exists in its initial state
        prod = adminClient.hosted().getProduct(prod.getId());
        assertThat(prod).isNotNull();

        // Consume the pool multiple times so we have entitlements to revoke
        int expectedNumberOfEnts = 5;
        for (int i = 0; i < expectedNumberOfEnts; i++) {
            ConsumerDTO guestUser = createGuestUser();
            ApiClient guestClient = ApiClients.ssl(guestUser);

            JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), bonusPool.getId(), 1);
            assertEquals(1, ents.size());

            assertThat(adminClient.consumers().getConsumer(guestUser.getUuid()))
                .isNotNull()
                .returns(1L, ConsumerDTO::getEntitlementCount);
        }

        // Verify the entitlement count for this pool
        assertThat(adminClient.pools().getPoolEntitlements(primaryPool.getId()))
            .hasSize(0);
        assertThat(adminClient.pools().getPoolEntitlements(bonusPool.getId()))
            .hasSize(expectedNumberOfEnts);

        // Modify the subscription upstream
        sub.setQuantity(1L);
        adminClient.hosted().updateSubscription(sub.getId(), sub);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools)
            .hasSize(2)
            .map(PoolDTO::getType)
            .containsExactlyInAnyOrder("NORMAL", "BONUS");

        primaryPool = pools.get(0).getType().equals("NORMAL") ? pools.get(0) : pools.get(1);
        bonusPool = pools.get(0).getType().equals("BONUS") ? pools.get(0) : pools.get(1);

        // Verify the entitlement count has changed
        assertThat(adminClient.pools().getPoolEntitlements(primaryPool.getId()))
            .isNotNull()
            .hasSize(0);

        assertThat(adminClient.pools().getPoolEntitlements(bonusPool.getId()))
            .isNotNull()
            .hasSize(1);
    }

    @Test
    @OnlyInHosted
    public void shouldInvalidateBonusPoolEntsWhenBonusPoolQuantityIsReduced() throws Exception {
        ContentDTO content = adminClient.hosted().createContent(Contents.random());
        ProductDTO prod = Products.random();

        Long virtLimit = 5L;
        prod.setAttributes(List.of(ProductAttributes.VirtualLimit.withValue(String.valueOf(virtLimit))));
        prod = adminClient.hosted().createProduct(prod);
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        Long subQuantity = 1L;
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod).quantity(subQuantity));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        // primary pool and bonus pool
        assertThat(pools)
            .hasSize(2)
            .map(PoolDTO::getType)
            .containsExactlyInAnyOrder("NORMAL", "BONUS");

        PoolDTO primaryPool = pools.get(0).getType().equals("NORMAL") ? pools.get(0) : pools.get(1);
        assertThat(primaryPool).returns(1L, PoolDTO::getQuantity);
        PoolDTO bonusPool = pools.get(0).getType().equals("BONUS") ? pools.get(0) : pools.get(1);
        assertThat(bonusPool).returns(virtLimit, PoolDTO::getQuantity);

        // Verify the product exists in its initial state
        prod = adminClient.hosted().getProduct(prod.getId());
        assertThat(prod).isNotNull();

        // Consume the pool multiple times so we have entitlements to revoke
        int expectedNumberOfEnts = 5;
        for (int i = 0; i < expectedNumberOfEnts; i++) {
            ConsumerDTO guestUser = createGuestUser();
            ApiClient guestClient = ApiClients.ssl(guestUser);

            JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), bonusPool.getId(), 1);
            assertEquals(1, ents.size());

            assertThat(adminClient.consumers().getConsumer(guestUser.getUuid()))
                .isNotNull()
                .returns(1L, ConsumerDTO::getEntitlementCount);
        }

        // Verify the entitlement count for this pool
        assertThat(adminClient.pools().getPoolEntitlements(primaryPool.getId()))
            .hasSize(0);
        assertThat(adminClient.pools().getPoolEntitlements(bonusPool.getId()))
            .hasSize(expectedNumberOfEnts);

        // Modify the subscription upstream
        prod.setAttributes(List.of(ProductAttributes.VirtualLimit.withValue("1")));
        adminClient.hosted().updateProduct(prod.getId(), prod);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools)
            .hasSize(2)
            .map(PoolDTO::getType)
            .containsExactlyInAnyOrder("NORMAL", "BONUS");

        // Verify the entitlement count has changed
        primaryPool = pools.get(0).getType().equals("NORMAL") ? pools.get(0) : pools.get(1);
        assertThat(primaryPool).returns(1L, PoolDTO::getQuantity);
        bonusPool = pools.get(0).getType().equals("BONUS") ? pools.get(0) : pools.get(1);
        assertThat(bonusPool).returns(1L, PoolDTO::getQuantity);
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntsWhenModifiedProductIdsOfContentChange() throws Exception {
        ContentDTO content = adminClient.hosted().createContent(Contents.random());
        ProductDTO prod = adminClient.hosted().createProduct(Products.random());
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);
        PoolDTO pool = pools.get(0);

        ConsumerDTO guestUser = createGuestUser();
        ApiClient guestClient = ApiClients.ssl(guestUser);

        JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());
        JsonNode cert = ents.get(0).get("certificates").get(0);
        JsonNode serialBeforeUpdate = cert.get("serial").get("serial");

        // Update the modifiedProductIds of content
        ProductDTO newProd = adminClient.hosted().createProduct(Products.random());
        content.modifiedProductIds(Set.of(newProd.getId()));
        adminClient.hosted().updateContent(content.getId(), content);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);

        assertThat(adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText()))
            .isNotNull()
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .isNotEqualTo(serialBeforeUpdate.longValue());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntsWhenModifiedProductidsOfContentOfAProvidedProductChange()
        throws Exception {
        ContentDTO provProdContent = adminClient.hosted().createContent(Contents.random());
        ProductDTO provProd = adminClient.hosted().createProduct(Products.random());
        provProd = adminClient.hosted().addContentToProduct(provProd.getId(), provProdContent.getId(), true);

        ContentDTO content = adminClient.hosted().createContent(Contents.random());
        ProductDTO prod = adminClient.hosted().createProduct(Products.random()
            .providedProducts(Set.of(provProd)));
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);
        PoolDTO pool = pools.get(0);

        ConsumerDTO guestUser = createGuestUser();
        ApiClient guestClient = ApiClients.ssl(guestUser);

        JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());
        assertEquals(1, ents.get(0).get("certificates").size());
        JsonNode cert = ents.get(0).get("certificates").get(0);
        assertNotNull(cert.get("serial"));
        JsonNode serialBeforeUpdate = cert.get("serial").get("serial");

        // Update the modifiedProductIds of provided product content
        ProductDTO newProd = adminClient.hosted().createProduct(Products.random());
        provProdContent.modifiedProductIds(Set.of(newProd.getId()));
        adminClient.hosted().updateContent(provProdContent.getId(), provProdContent);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);

        assertThat(adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText()))
            .isNotNull()
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .isNotEqualTo(serialBeforeUpdate.longValue());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntsWhenModifiedProductIdsOfContentOfADerivedProvidedProductChange()
        throws Exception {
        ContentDTO derivedProvProdContent = adminClient.hosted().createContent(Contents.random());
        ProductDTO derivedProvProd = adminClient.hosted().createProduct(Products.random());
        derivedProvProd = adminClient.hosted()
            .addContentToProduct(derivedProvProd.getId(), derivedProvProdContent.getId(), true);

        ProductDTO derivedProd = adminClient.hosted()
            .createProduct(Products.random().providedProducts(Set.of(derivedProvProd)));

        ContentDTO provProdContent = adminClient.hosted().createContent(Contents.random());
        ProductDTO provProd = adminClient.hosted().createProduct(Products.random());
        provProd = adminClient.hosted().addContentToProduct(provProd.getId(), provProdContent.getId(), true);

        ContentDTO content = adminClient.hosted().createContent(Contents.random());
        ProductDTO prod = adminClient.hosted().createProduct(Products.random()
            .providedProducts(Set.of(provProd))
            .derivedProduct(derivedProd));
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);
        PoolDTO pool = pools.get(0);

        ConsumerDTO guestUser = createGuestUser();
        ApiClient guestClient = ApiClients.ssl(guestUser);

        JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());
        assertEquals(1, ents.get(0).get("certificates").size());
        JsonNode cert = ents.get(0).get("certificates").get(0);
        assertNotNull(cert.get("serial"));
        JsonNode serialBeforeUpdate = cert.get("serial").get("serial");

        // Update the modifiedProductIds of provided product content
        ProductDTO newProd = adminClient.hosted().createProduct(Products.random());
        derivedProvProdContent.modifiedProductIds(Set.of(newProd.getId()));
        adminClient.hosted().updateContent(derivedProvProdContent.getId(), derivedProvProdContent);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);

        assertThat(adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText()))
            .isNotNull()
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .isNotEqualTo(serialBeforeUpdate.longValue());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntsWhenProvidedProductIsAdded() throws Exception {
        ProductDTO prod = createProductWithContent();
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);
        PoolDTO pool = pools.get(0);

        ConsumerDTO guestUser = createGuestUser();
        ApiClient guestClient = ApiClients.ssl(guestUser);

        JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());
        assertEquals(1, ents.get(0).get("certificates").size());
        JsonNode cert = ents.get(0).get("certificates").get(0);
        assertNotNull(cert.get("serial"));
        JsonNode serialBeforeUpdate = cert.get("serial").get("serial");

        // Update the modifiedProductIds of content
        ContentDTO provProdContent = adminClient.hosted().createContent(Contents.random());
        ProductDTO provProd = adminClient.hosted().createProduct(Products.random());
        provProd = adminClient.hosted().addContentToProduct(provProd.getId(), provProdContent.getId(), true);
        prod.setProvidedProducts(Set.of(provProd));
        prod = adminClient.hosted().updateProduct(prod.getId(), prod);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);

        assertThat(adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText()))
            .isNotNull()
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .isNotEqualTo(serialBeforeUpdate.longValue());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntsWhenProvidedProductIsRemoved() throws Exception {
        ContentDTO provProdContent = adminClient.hosted().createContent(Contents.random());
        ProductDTO provProd = adminClient.hosted().createProduct(Products.random());
        provProd = adminClient.hosted().addContentToProduct(provProd.getId(), provProdContent.getId(), true);

        ContentDTO content = adminClient.hosted().createContent(Contents.random());
        ProductDTO prod = adminClient.hosted().createProduct(Products.random()
            .providedProducts(Set.of(provProd)));
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);
        PoolDTO pool = pools.get(0);

        ConsumerDTO guestUser = createGuestUser();
        ApiClient guestClient = ApiClients.ssl(guestUser);

        JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());
        assertEquals(1, ents.get(0).get("certificates").size());
        JsonNode cert = ents.get(0).get("certificates").get(0);
        assertNotNull(cert.get("serial"));
        JsonNode serialBeforeUpdate = cert.get("serial").get("serial");

        // Remove the provided product
        prod.setProvidedProducts(Set.of());
        prod = adminClient.hosted().updateProduct(prod.getId(), prod);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);

        assertThat(adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText()))
            .isNotNull()
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .isNotEqualTo(serialBeforeUpdate.longValue());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntsWhenLabelOfAContentChanges() throws Exception {
        ContentDTO content = adminClient.hosted().createContent(Contents.random().label("label"));
        ProductDTO prod = adminClient.hosted().createProduct(Products.random());
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);
        PoolDTO pool = pools.get(0);

        ConsumerDTO guestUser = createGuestUser();
        ApiClient guestClient = ApiClients.ssl(guestUser);

        JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());
        assertEquals(1, ents.get(0).get("certificates").size());
        JsonNode cert = ents.get(0).get("certificates").get(0);
        assertNotNull(cert.get("serial"));
        JsonNode serialBeforeUpdate = cert.get("serial").get("serial");

        // Update the label of the content
        content.label(StringUtil.random("label-"));
        content = adminClient.hosted().updateContent(content.getId(), content);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);

        assertThat(adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText()))
            .isNotNull()
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .isNotEqualTo(serialBeforeUpdate.longValue());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntsWhenReleaseVerOfAContentChanges() throws Exception {
        ContentDTO content = adminClient.hosted().createContent(Contents.random().releaseVer("relVer"));
        ProductDTO prod = adminClient.hosted().createProduct(Products.random());
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);
        PoolDTO pool = pools.get(0);

        ConsumerDTO guestUser = createGuestUser();
        ApiClient guestClient = ApiClients.ssl(guestUser);

        JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());
        assertEquals(1, ents.get(0).get("certificates").size());
        JsonNode cert = ents.get(0).get("certificates").get(0);
        assertNotNull(cert.get("serial"));
        JsonNode serialBeforeUpdate = cert.get("serial").get("serial");

        // Update the release version of the content
        content.releaseVer(StringUtil.random("relVer-"));
        content = adminClient.hosted().updateContent(content.getId(), content);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);

        assertThat(adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText()))
            .isNotNull()
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .isNotEqualTo(serialBeforeUpdate.longValue());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntsWhenVendorOfAContentChanges() throws Exception {
        ContentDTO content = adminClient.hosted().createContent(Contents.random().vendor("vendor"));
        ProductDTO prod = adminClient.hosted().createProduct(Products.random());
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);
        PoolDTO pool = pools.get(0);

        ConsumerDTO guestUser = createGuestUser();
        ApiClient guestClient = ApiClients.ssl(guestUser);

        JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());
        assertEquals(1, ents.get(0).get("certificates").size());
        JsonNode cert = ents.get(0).get("certificates").get(0);
        assertNotNull(cert.get("serial"));
        JsonNode serialBeforeUpdate = cert.get("serial").get("serial");

        // Update the vendor of the content
        content.vendor(StringUtil.random("vendor-"));
        content = adminClient.hosted().updateContent(content.getId(), content);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);

        assertThat(adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText()))
            .isNotNull()
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .isNotEqualTo(serialBeforeUpdate.longValue());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntsWhenAddingAContent() throws Exception {
        ProductDTO prod = adminClient.hosted().createProduct(Products.random());
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);
        PoolDTO pool = pools.get(0);

        ConsumerDTO guestUser = createGuestUser();
        ApiClient guestClient = ApiClients.ssl(guestUser);

        JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());
        assertEquals(1, ents.get(0).get("certificates").size());
        JsonNode cert = ents.get(0).get("certificates").get(0);
        assertNotNull(cert.get("serial"));
        JsonNode serialBeforeUpdate = cert.get("serial").get("serial");

        // Add content to product
        ContentDTO content = adminClient.hosted().createContent(Contents.random().vendor("vendor"));
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);

        assertThat(adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText()))
            .isNotNull()
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .isNotEqualTo(serialBeforeUpdate.longValue());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntsWhenDeletingContent() throws Exception {
        ContentDTO content = adminClient.hosted().createContent(Contents.random().vendor("vendor"));
        ProductDTO prod = adminClient.hosted().createProduct(Products.random());
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);
        PoolDTO pool = pools.get(0);

        ConsumerDTO guestUser = createGuestUser();
        ApiClient guestClient = ApiClients.ssl(guestUser);

        JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());
        assertEquals(1, ents.get(0).get("certificates").size());
        JsonNode cert = ents.get(0).get("certificates").get(0);
        assertNotNull(cert.get("serial"));
        JsonNode serialBeforeUpdate = cert.get("serial").get("serial");

        // remove content from product
        adminClient.hosted().removeContentFromProduct(prod.getId(), List.of(content.getId()));

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);

        assertThat(adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText()))
            .isNotNull()
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .isNotEqualTo(serialBeforeUpdate.longValue());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntsWhenPoolStartDateChanges() throws Exception {
        ProductDTO prod = createProductWithContent();
        SubscriptionDTO sub = adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);
        PoolDTO pool = pools.get(0);

        ConsumerDTO guestUser = createGuestUser();
        ApiClient guestClient = ApiClients.ssl(guestUser);

        JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());
        assertEquals(1, ents.get(0).get("certificates").size());
        JsonNode cert = ents.get(0).get("certificates").get(0);
        assertNotNull(cert.get("serial"));
        JsonNode serialBeforeUpdate = cert.get("serial").get("serial");

        // Update subscription, then refresh. The entitlements should be regenerated
        sub.startDate(OffsetDateTime.now().minusDays(10));
        adminClient.hosted().updateSubscription(sub.getId(), sub);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);

        assertThat(adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText()))
            .isNotNull()
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .isNotEqualTo(serialBeforeUpdate.longValue());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntsWhenPoolEndDataChanges() throws Exception {
        ProductDTO prod = createProductWithContent();
        SubscriptionDTO sub = adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);
        PoolDTO pool = pools.get(0);

        ConsumerDTO guestUser = createGuestUser();
        ApiClient guestClient = ApiClients.ssl(guestUser);

        JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());
        assertEquals(1, ents.get(0).get("certificates").size());
        JsonNode cert = ents.get(0).get("certificates").get(0);
        assertNotNull(cert.get("serial"));
        JsonNode serialBeforeUpdate = cert.get("serial").get("serial");

        // Update subscription, then refresh. The entitlements should be regenerated
        sub.endDate(OffsetDateTime.now().plusDays(10));
        adminClient.hosted().updateSubscription(sub.getId(), sub);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);

        assertThat(adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText()))
            .isNotNull()
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .isNotEqualTo(serialBeforeUpdate.longValue());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntsWhenPoolProductChanges() throws Exception {
        ProductDTO product = createProductWithContent();
        adminClient.hosted().createSubscription(Subscriptions.random(owner, product));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertEquals(1, pools.size());

        ConsumerDTO guestUser = createGuestUser();
        ApiClient guestClient = ApiClients.ssl(guestUser);

        JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), pools.get(0).getId(), 1);
        assertEquals(1, ents.size());
        assertEquals(1, ents.get(0).get("certificates").size());
        JsonNode cert = ents.get(0).get("certificates").get(0);
        assertNotNull(cert.get("serial"));
        JsonNode serialBeforeUpdate = cert.get("serial").get("serial");

        List<EntitlementDTO> consumerEnts = adminClient.consumers().listEntitlements(guestUser.getUuid());
        assertThat(consumerEnts)
            .singleElement()
            .extracting(EntitlementDTO::getCertificates)
            .isNotNull();

        // Update product, then refresh. The entitlements should be regenerated
        product.setAttributes(List.of(ProductAttributes.Type.withValue(StringUtil.random("type-"))));
        product = adminClient.hosted().updateProduct(product.getId(), product);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);

        assertThat(adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText()))
            .isNotNull()
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .isNotEqualTo(serialBeforeUpdate.longValue());
    }

    @Test
    @OnlyInHosted
    public void shouldRegenerateEntsWhenDerivedPoolsAreRemoved() throws Exception {
        /*
            Testing for BZ 1567922:
            - We have a main pool with a finite quantity, and also a virt_limit attribute on it
            - A host consumes entitlement(s) from it; creating a derived pool as a result of that entitlement
            attachment
            - The main pool is changed in one of two ways:
            a) the quantity of it is reduced, resulting in the host's entitlement being revoked (because now
            it would be overconsuming), and that would mean we need to delete the derived pool that was
            created because of it, or
            b) virt_limit is removed from the main pool's product (meaning it no longer should provide derived
            pools), which would mean we need to delete the derived pool
            - That derived pool that was marked for deletion is attempted to be locked+updated later on, which
            results on some kind of error
         */
        ContentDTO derivedProvProdContent = adminClient.hosted().createContent(Contents.random());
        ProductDTO derivedProvProd = adminClient.hosted().createProduct(Products.random());
        derivedProvProd = adminClient.hosted()
            .addContentToProduct(derivedProvProd.getId(), derivedProvProdContent.getId(), true);

        ProductDTO derivedProd = adminClient.hosted()
            .createProduct(Products.random().providedProducts(Set.of(derivedProvProd)));

        ContentDTO content = adminClient.hosted().createContent(Contents.random());
        ProductDTO prod = adminClient.hosted().createProduct(Products.random()
            .derivedProduct(derivedProd));
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);
        adminClient.hosted().createSubscription(Subscriptions.random(owner, prod));

        refreshPools(adminClient, owner.getKey());
        List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);
        PoolDTO pool = pools.get(0);

        ConsumerDTO guestUser = createGuestUser();
        ApiClient guestClient = ApiClients.ssl(guestUser);

        JsonNode ents = guestClient.consumers().bindPool(guestUser.getUuid(), pool.getId(), 1);
        assertEquals(1, ents.size());
        assertEquals(1, ents.get(0).get("certificates").size());
        JsonNode cert = ents.get(0).get("certificates").get(0);
        assertNotNull(cert.get("serial"));
        JsonNode serialBeforeUpdate = cert.get("serial").get("serial");

        // remove the derived product
        prod.derivedProduct(null);
        prod = adminClient.hosted().updateProduct(prod.getId(), prod);

        refreshPools(adminClient, owner.getKey());
        pools = adminClient.pools().listPoolsByOwner(owner.getId());
        assertThat(pools).hasSize(1);

        assertThat(adminClient.entitlements().getEntitlement(ents.get(0).get("id").asText()))
            .isNotNull()
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .isNotNull()
            .extracting(CertificateDTO::getSerial)
            .isNotNull()
            .isNotEqualTo(serialBeforeUpdate.longValue());
    }

    @Test
    @OnlyInHosted
    public void shouldDeduplicateProductsAndContent() throws Exception {
        OwnerDTO owner2 = adminClient.owners().createOwner(Owners.random());
        OwnerDTO owner3 = adminClient.owners().createOwner(Owners.random());

        // Create products and content to be shared across all orgs
        ProductDTO provProd1 = createProductWithContent();
        ProductDTO provProd2 = createProductWithContent();
        ProductDTO provProd3 = createProductWithContent();

        ProductDTO product = Products.random();
        product.setProvidedProducts(Set.of(provProd1, provProd2, provProd3));
        product = adminClient.hosted().createProduct(product);

        // Set up orgs with different subscriptions containing the product
        adminClient.hosted().createSubscription(Subscriptions.random(owner, product));
        adminClient.hosted().createSubscription(Subscriptions.random(owner2, product));
        adminClient.hosted().createSubscription(Subscriptions.random(owner3, product));

        // Refresh orgs in serial (note: this *cannot* safely be done in parallel)
        refreshPools(adminClient, owner.getKey());
        refreshPools(adminClient, owner2.getKey());
        refreshPools(adminClient, owner3.getKey());

        // Verify that the products used by both org is the same underlying product (i.e. same product UUID)
        List<String> actualProdUuids = new ArrayList<>();
        for (OwnerDTO productOwner : List.of(owner, owner2, owner3)) {
            List<PoolDTO> pools = adminClient.pools().listPoolsByOwner(productOwner.getId());
            assertThat(pools)
                .isNotNull()
                .hasSize(1);

            ProductDTO actualProd = adminClient.hosted().getProduct(pools.get(0).getProductId());
            assertNotNull(actualProd);
            actualProdUuids.add(actualProd.getUuid());
        }

        assertThat(actualProdUuids)
            .hasSize(3)
            .containsExactlyInAnyOrder(provProd1.getUuid(), provProd2.getUuid(), provProd3.getUuid());
    }

    @Test
    @OnlyInHosted
    public void shouldDetectProductChangesAcrossMultipleOrgsEntitlementRegeneration() {
        // With global products, we need to verify that one org refreshing the global product
        // definitions does not prevent subsequent refreshes for orgs using the same products from
        // detecting product changes and making necessary pool updates.

        OwnerDTO owner1 = adminClient.owners().createOwner(Owners.random());
        OwnerDTO owner2 = adminClient.owners().createOwner(Owners.random());
        ConsumerDTO owner1Consumer = adminClient.consumers().createConsumer(Consumers.random(owner1));
        ConsumerDTO owner2Consumer = adminClient.consumers().createConsumer(Consumers.random(owner2));

        // Create a basic pool for the subscription that both orgs will consume
        ProductDTO product = adminClient.hosted().createProduct(Products.random());

        adminClient.hosted().createSubscription(Subscriptions.random(owner1, product));
        adminClient.hosted().createSubscription(Subscriptions.random(owner2, product));

        // Refresh our orgs and verify they both have one pool
        this.refreshPools(adminClient, owner1.getKey());
        this.refreshPools(adminClient, owner2.getKey());

        List<PoolDTO> owner1Pools = adminClient.pools().listPoolsByOwner(owner1.getId());
        assertThat(owner1Pools).hasSize(1);

        List<PoolDTO> owner2Pools = adminClient.pools().listPoolsByOwner(owner2.getId());
        assertThat(owner2Pools).hasSize(1);

        // Consume both pools so we get an entitlement
        List<EntitlementDTO> owner1Entitlements = adminClient.consumers()
            .bindPoolSync(owner1Consumer.getUuid(), owner1Pools.get(0).getId(), 1);
        assertThat(owner1Entitlements).hasSize(1);

        EntitlementDTO owner1Entitlement = owner1Entitlements.get(0);
        CertificateDTO owner1EntCertificate = owner1Entitlement.getCertificates()
            .iterator()
            .next();

        List<EntitlementDTO> owner2Entitlements = adminClient.consumers()
            .bindPoolSync(owner2Consumer.getUuid(), owner2Pools.get(0).getId(), 1);
        assertThat(owner2Entitlements).hasSize(1);

        EntitlementDTO owner2Entitlement = owner2Entitlements.get(0);
        CertificateDTO owner2EntCertificate = owner2Entitlement.getCertificates()
            .iterator()
            .next();

        // Update the product with a new name
        product.setName(product.getName() + " updated");
        product = adminClient.hosted().updateProduct(product.getId(), product);

        // Refresh first org and verify its client gets a new entitlement
        this.refreshPools(adminClient, owner1.getKey());

        List<EntitlementDTO> owner1EntitlementsUpdate = adminClient.consumers()
            .listEntitlementsWithRegen(owner1Consumer.getUuid());

        assertThat(owner1EntitlementsUpdate)
            .isNotNull()
            .singleElement()
            .returns(owner1Entitlement.getId(), EntitlementDTO::getId)
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .doesNotReturn(owner1EntCertificate.getId(), CertificateDTO::getId);

        // Verify org 2 has not been affected
        List<EntitlementDTO> owner2EntitlementsUpdateA = adminClient.consumers()
            .listEntitlementsWithRegen(owner2Consumer.getUuid());

        assertThat(owner2EntitlementsUpdateA)
            .isNotNull()
            .singleElement()
            .returns(owner2Entitlement.getId(), EntitlementDTO::getId)
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .returns(owner2EntCertificate.getId(), CertificateDTO::getId);

        // Refresh the second org and verify it now detects the product change and regenerates its
        // entitlement(s)
        this.refreshPools(adminClient, owner2.getKey());

        List<EntitlementDTO> owner2EntitlementsUpdateB = adminClient.consumers()
            .listEntitlementsWithRegen(owner2Consumer.getUuid());

        assertThat(owner2EntitlementsUpdateB)
            .isNotNull()
            .singleElement()
            .returns(owner2Entitlement.getId(), EntitlementDTO::getId)
            .extracting(EntitlementDTO::getCertificates, as(collection(CertificateDTO.class)))
            .singleElement()
            .doesNotReturn(owner2EntCertificate.getId(), CertificateDTO::getId);
    }

    @Test
    @OnlyInHosted
    public void shouldDetectProductChangesAcrossMultipleOrgsDerivedPoolGeneration() {
        // With global products, we need to verify that one org refreshing the global product
        // definitions does not prevent subsequent refreshes for orgs using the same products from
        // detecting product changes and making necessary pool updates.

        OwnerDTO owner1 = adminClient.owners().createOwner(Owners.random());
        OwnerDTO owner2 = adminClient.owners().createOwner(Owners.random());

        // Create a basic pool for the subscription that both orgs will consume
        ProductDTO product = adminClient.hosted().createProduct(Products.random());

        adminClient.hosted().createSubscription(Subscriptions.random(owner1, product));
        adminClient.hosted().createSubscription(Subscriptions.random(owner2, product));

        // Refresh our orgs and verify they both have one pool
        this.refreshPools(adminClient, owner1.getKey());
        this.refreshPools(adminClient, owner2.getKey());

        List<PoolDTO> owner1Pools = adminClient.pools().listPoolsByOwner(owner1.getId());
        assertThat(owner1Pools).hasSize(1);

        List<PoolDTO> owner2Pools = adminClient.pools().listPoolsByOwner(owner2.getId());
        assertThat(owner2Pools).hasSize(1);

        // Update the product with a new derived product
        ProductDTO derivedProduct = adminClient.hosted().createProduct(Products.random());

        product.derivedProduct(derivedProduct)
            .addAttributesItem(ProductAttributes.VirtualLimit.withValue("unlimited"));

        product = adminClient.hosted().updateProduct(product.getId(), product);

        // Refresh first org and verify it has a new derived pool
        this.refreshPools(adminClient, owner1.getKey());

        assertThat(adminClient.pools().listPoolsByOwner(owner1.getId()))
            .isNotNull()
            .hasSize(2);

        // Refresh the second org and verify it *also* gets the new derived pool
        this.refreshPools(adminClient, owner2.getKey());

        assertThat(adminClient.pools().listPoolsByOwner(owner1.getId()))
            .isNotNull()
            .hasSize(2);
    }

    @Test
    @OnlyInHosted
    public void shouldDetectProductChangesAcrossMultipleOrgsSCACertificateRegeneration()
        throws InterruptedException {
        // With global products, SCA gets a little bit more aggressive in terms of refresh. Whenever
        // a product is detected as "changed", we update the lastContentUpdate field on every org
        // that has a pool referencing it. This should trigger SCA cert refreshes even outside of
        // an org-specific refresh.

        OwnerDTO owner1 = adminClient.owners().createOwner(Owners.randomSca());
        OwnerDTO owner2 = adminClient.owners().createOwner(Owners.randomSca());
        ConsumerDTO owner1Consumer = adminClient.consumers().createConsumer(Consumers.random(owner1));
        ConsumerDTO owner2Consumer = adminClient.consumers().createConsumer(Consumers.random(owner2));

        // Create a basic pool for the subscription that both orgs will consume
        ProductDTO product = adminClient.hosted().createProduct(Products.random());

        adminClient.hosted().createSubscription(Subscriptions.random(owner1, product));
        adminClient.hosted().createSubscription(Subscriptions.random(owner2, product));

        // Refresh our orgs and verify they both have one pool
        this.refreshPools(adminClient, owner1.getKey());
        this.refreshPools(adminClient, owner2.getKey());

        List<PoolDTO> owner1Pools = adminClient.pools().listPoolsByOwner(owner1.getId());
        assertThat(owner1Pools).hasSize(1);

        JsonNode owner1SCAContentBody1 = adminClient.consumers()
            .getContentAccessBodyJson(owner1Consumer.getUuid(), null);

        String owner1SCALastUpdate1 = owner1SCAContentBody1.get("lastUpdate").asText();
        String owner1SCAContent1 = owner1SCAContentBody1.get("contentListing")
            .valueStream()
            .findFirst()
            .orElseThrow()
            .get(1)
            .asText();

        List<PoolDTO> owner2Pools = adminClient.pools().listPoolsByOwner(owner2.getId());
        assertThat(owner2Pools).hasSize(1);

        JsonNode owner2SCAContentBody1 = adminClient.consumers()
            .getContentAccessBodyJson(owner2Consumer.getUuid(), null);

        String owner2SCALastUpdate1 = owner2SCAContentBody1.get("lastUpdate").asText();
        String owner2SCAContent1 = owner2SCAContentBody1.get("contentListing")
            .valueStream()
            .findFirst()
            .orElseThrow()
            .get(1)
            .asText();

        // Update the product with new content
        ContentDTO content = adminClient.hosted().createContent(Contents.random());
        adminClient.hosted().addContentToProduct(product.getId(), content.getId(), true);

        // Refresh first org and verify it gets new SCA content blobs
        sleep(1000);
        this.refreshPools(adminClient, owner1.getKey());

        JsonNode owner1SCAContentBody2 = adminClient.consumers()
            .getContentAccessBodyJson(owner1Consumer.getUuid(), null);

        String owner1SCALastUpdate2 = owner1SCAContentBody2.get("lastUpdate").asText();
        String owner1SCAContent2 = owner1SCAContentBody2.get("contentListing")
            .valueStream()
            .findFirst()
            .orElseThrow()
            .get(1)
            .asText();

        assertNotEquals(owner1SCAContent1, owner1SCAContent2);
        assertNotEquals(owner1SCALastUpdate1, owner1SCALastUpdate2);

        // The second org should also be affected by this in SCA mode, even without an explicit
        // refresh
        JsonNode owner2SCAContentBody2 = adminClient.consumers()
            .getContentAccessBodyJson(owner2Consumer.getUuid(), null);

        String owner2SCALastUpdate2 = owner2SCAContentBody2.get("lastUpdate").asText();
        String owner2SCAContent2 = owner2SCAContentBody2.get("contentListing")
            .valueStream()
            .findFirst()
            .orElseThrow()
            .get(1)
            .asText();

        assertNotEquals(owner2SCAContent1, owner2SCAContent2);
        assertNotEquals(owner2SCALastUpdate1, owner2SCALastUpdate2);

        // An explicit refresh should also trigger another regen, since its pool will be flagged as
        // dirty. Note that this behavior is not explicitly required for future implementations, so
        // if this changes in the future, drop this additional check.
        sleep(1000);
        this.refreshPools(adminClient, owner2.getKey());

        JsonNode owner2SCAContentBody3 = adminClient.consumers()
            .getContentAccessBodyJson(owner2Consumer.getUuid(), null);

        String owner2SCALastUpdate3 = owner2SCAContentBody3.get("lastUpdate").asText();
        String owner2SCAContent3 = owner2SCAContentBody3.get("contentListing")
            .valueStream()
            .findFirst()
            .orElseThrow()
            .get(1)
            .asText();

        assertNotEquals(owner2SCAContent1, owner2SCAContent2);
        assertNotEquals(owner2SCALastUpdate1, owner2SCALastUpdate2);
        assertNotEquals(owner2SCAContent1, owner2SCAContent3);
        assertNotEquals(owner2SCALastUpdate1, owner2SCALastUpdate3);
        assertNotEquals(owner2SCAContent2, owner2SCAContent3);
        assertNotEquals(owner2SCALastUpdate2, owner2SCALastUpdate3);
    }

    private AsyncJobStatusDTO refreshPools(ApiClient client, String ownerKey) {
        AsyncJobStatusDTO job = client.owners().refreshPools(ownerKey, true);
        if (!CandlepinMode.isHosted()) {
            return null;
        }

        assertNotNull(job);
        job = client.jobs().waitForJob(job);

        assertThatJob(job)
            .isFinished();

        return job;
    }

    private ProductDTO createProductWithContent() {
        ContentDTO content = adminClient.hosted().createContent(Contents.random());
        ProductDTO prod = adminClient.hosted().createProduct(Products.random());
        prod = adminClient.hosted().addContentToProduct(prod.getId(), content.getId(), true);

        return prod;
    }

    private ConsumerDTO createGuestUser() {
        ConsumerDTO guestUser = Consumers.random(owner, ConsumerTypes.System);
        guestUser.setUsername("admin");
        guestUser.setFacts(Map.of("system.certificate_version", "3.0", "virt.is_guest", "true"));

        return adminClient.consumers().createConsumer(guestUser, "admin", ownerKey, null, true);
    }

    private static void compareProducts(ProductDTO expected, ProductDTO actual) {
        assertEquals(expected.getId(), actual.getId());
        assertEquals(expected.getName(), actual.getName());
        assertEquals(expected.getMultiplier(), actual.getMultiplier());
        assertEquals(expected.getAttributes(), actual.getAttributes());
    }

    private static void compareBrandings(BrandingDTO expected, BrandingDTO actual) {
        assertEquals(expected.getProductId(), actual.getProductId());
        assertEquals(expected.getName(), actual.getName());
        assertEquals(expected.getType(), actual.getType());
    }

    private static void compareBrandings(Collection<BrandingDTO> expected, Collection<BrandingDTO> actual) {
        expected.forEach(brand -> brand.created(null).updated(null));
        actual.forEach(brand -> brand.created(null).updated(null));

        assertThat(actual)
            .hasSize(expected.size())
            .containsExactlyInAnyOrderElementsOf(expected);
    }

}
