# Candlepin docker containers
This folder contains docker configurations that are primarily used for running the various unit/spec/smoke tests.
Much of the old scripting has been replaced with invocations of `docker-compose`, and is required to use this. Note that
the following is useful for running tests directly (for example, you want to test something before you commit it);
ideally this would be triggered automatically via jenkins [[1]](https://github.com/candlepin/candlepin-jobs).

## Building Images
To build the images run the `build-images` script.
If you choose to push the images to a different docker registry, change the REGISTRY value found in `./.env`.
Basic invocations of `build-images` are as follows:

```sh
# build all images
./build-images
# build all images and push to a registry
./build-images -p
# build all images but speed it up using caching
./build-images -c
# build only one image
# see the top level of docker-compose-build.yml under 'services:' for a list of image names
./build-images <image_name>
# build only one image and push to a registry
./build-images -p <image_name>
```
These options can be combined.  See `build-images -h` for more information.

## Running containers
The main interface for this is the `test` script.  This script is designed as a basic wrapper around `docker-compose`
in order to stop and clean up existing running containers, as well as invoking the candlepin test script with default
options.  This script will mount your current development checkout of candlepin (this repo) into `/candlepin-dev/`
and bring up a database at hostname `db` on the running container

By default the `test` script will run candlepin against a postgres database.  You can change this behavior with the
`-m` or `-p` flags which will use mysql or postgres respectively. To change the default permanently,
run the `switch-defaults` script. Additionally, you can use the `-x` flag which will use no database at all (useful
for running tasks that do not require a running server and database, such as unit tests, checkstyle, translation
validation). Finally, the `-q` flag does what the `-x` flag does already, plus requires a sonarqube server certificate
(used for running the sonarqube analysis upload task).

To run multiple candlepin containers simultaneously, give each invocation of `test` a unique name with the `-n` flag.

You can also use the `-d` option which will run containers in detached mode, keeping them from being removed
when the test script exits.

Using the `-e` flag will expose ports 8443, 8080 and 22 to the host.

Some useful invocations of the `test` command:

```sh
# run only unit tests
./test -x -c '/usr/bin/cp-test -u'

# screw tests, give me a shell and a mysql db
./test -m -c '/bin/bash'

# run mysql and postgres tests at the same time
./test -m -n "my_mysql_tests"
./test -p -n "my_postgres_tests"

# Run containers detached, don't remove containers when ./test exits, and expose ports
# 8443/8080/22 to the host. The cp-test -R option will generate test data, content & rpms,
# and the -s option will make sure the candlepin container will drop into the shell once the
# data generation is done, to avoid the container shutting down.
./test -d -e -c '/usr/bin/cp-test -R -s'
```

See `test -h` for more options.

## Design notes
Each candlepin / database combination is a different compose.  Each compose will bring up an isolated docker network where
the candlepin server is at hostname `candlepin` and the database is at hostname `db`.  The goal of this separation was to
be able to use an off the shelf solution for the databases. The advantages of this are:

1. No longer have to maintain extra supervisord configs
1. No longer have to maintain the database install, and db versions can be trivially upgraded
1. The actual candlepin image is now roughly 1/3rd the size of the bundled version
1. We now have more composibility with our docker environment
  * custom databases with preloaded data could be made now and run against any candlepin
1. Since the container will mount in the candlepin checkout, we no longer have to rebuild the image for every candlepin change
  * Jenkins environments will already have checked candlepin out
  * Dev environments will already have checked canelpin out
  * Only changes to the `docker/candlepin-base` or candlepin updates in brew (for the `docker/candlepin-rhel*` folders) would require a rebuild
  * This saves tons of space on our build machines.

