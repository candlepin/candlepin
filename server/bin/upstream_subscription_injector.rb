#!/usr/bin/env ruby
# Upstream subscription injector
# Loads subscription information into the Candlepin HostedTest adapter for testing.
#
# - The provided json files are expected to be a subscription object or array of subscription
#   objects
# - If the subscription does not define an ID, one will be generated for it
# - Any owner defined on the subscriptions will be ignored and overwritten with one generated
#   for the owner key given at runtime
# - Upstream subscription arrays can be generated by enabling TRACE level logging for an owner
#   during refresh in hosted

require 'optparse'
require 'json'
require 'digest'

require_relative "../client/ruby/candlepin_api"



@options = {}

def log(message)
    puts message unless @options[:silent]
end

def terminate(message)
    $stderr.puts "ERROR: #{message}"
    exit
end

def generate_subscription_id(filename, index, subscription)
    sid = Digest::MD5.hexdigest "#{filename}.#{index}"

    log("Generated ID for subscription \##{index} from #{filename}: #{sid}")
    return sid
end

# Checks that Candlepin is running in standalone mode with the hosted test adapter
def check_candlepin_configuration(candlepin)
    status = candlepin.get_status()
    standalone = (status['standalone'].to_s.downcase == 'true')

    terminate("Cannot inject upstream data; Candlepin is running in standalone mode") if standalone

    hosted_adapter = false

    begin
        response = candlepin.get('/hostedtest/alive', {}, 'text/plain', true)
        hosted_adapter = (response.to_s.downcase == 'true')
    rescue RestClient::ResourceNotFound
        # CP running without the Hosted adapter
    end

    terminate("Cannot inject upstream data; Hosted adapter is absent or disabled") if !hosted_adapter
end

def load_subscriptions(filename)
    begin
        json_file = File.open(filename)
        subscriptions = JSON.load(json_file)
        json_file.close()

        # If we only get a single subscription object out of this, convert it to an array for uniform processing
        if !subscriptions.is_a?(Array)
            subscriptions = [subscriptions]
        end

        return subscriptions
    rescue
        terminate("Unable to parse provided subscription file: #{filename}\n"\
            "Ensure the file is readable and is a JSON-formatted subscription or array of subscriptions")
    end
end

def clear_upstream_data(candlepin)
  candlepin.delete('/hostedtest', {}, nil, true)
end

def create_upstream_subscription(candlepin, subscription_id, owner_key, params = {})
    start_date = params.delete(:start_date) || Date.today
    end_date = params.delete(:end_date) || start_date + 365

    # Define subscription with defaults & specified params
    subscription = {
        'startDate' => start_date,
        'endDate'   => end_date,
        'quantity'  => 1
    }

    # Do not copy these with the rest of the merged keys
    filter = ['id', 'owner', 'ownerId']

    params.each do |key, value|
        # Convert the key to snake case so we can support whatever is thrown at us
        key = key.to_s.gsub(/_(\w)/){$1.upcase}

        if !filter.include?(key)
            subscription[key] = value
        end
    end

    # Forcefully set critical identifiers
    subscription['id'] = subscription_id
    subscription['owner'] = { :key => owner_key }

    # Create or update subscription in our upstream store
    begin
        candlepin.post('hostedtest/subscriptions', {}, subscription)
    rescue RestClient::Conflict
        log("  Subscription #{subscription['id']} already exists; updating existing entry")
        candlepin.put("hostedtest/subscriptions/#{subscription['id']}", {}, subscription)
    end
end


# Set up the CLI options
@options = {}
optparse = OptionParser.new do |opts|
    file = File.basename(__FILE__)
    opts.banner = "Usage: #{file} [options] owner_key json_file [json_file_2 [json_file_3 [...]]]\n\nOptions:"

    @options[:user] = 'admin'
    opts.on('--username [USER]', 'Username to connect with; defaults to "admin".') do |opt|
        @options[:user] = opt
    end

    @options[:password] = 'admin'
    opts.on('--password [PASSWORD]', 'Password to authenticate the user with; defaults to "admin".') do |opt|
        @options[:password] = opt
    end

    @options[:server] = 'localhost'
    opts.on('--server [SERVERNAME]', String, 'Server FQDN; defaults to "localhost"') do |opt|
        @options[:server] = opt
    end

    @options[:port] = 8443
    opts.on('--port [PORTNUM]', 'Port number for the Candlepin server; defaults to 8443') do |opt|
        @options[:port] = opt.to_i
    end

    @options[:context] = 'candlepin'
    opts.on('--context [CONTEXT]', 'Context to use for the Candlepin connection; defaults to "candlepin"') do |opt|
        @options[:context] = opt
    end

    @options[:uuid] = nil
    opts.on('--uuid [UUID]', 'UUID to use for the Candlepin connection; defaults to nil') do |opt|
        @options[:uuid] = opt
    end

    @options[:ssl] = true
    opts.on('--nossl', 'Do not use SSL; defaults to false') do
        @options[:ssl] = false
    end

    @options[:trusted_user] = false
    opts.on('--trusted', 'If the Candlepin user should be trusted; defaults to false') do
        @options[:trusted_user] = true
    end

    @options[:clean] = false
    opts.on('--clean', 'Clears the upstream subscription data before injecting the new data') do
        @options[:clean] = true
    end

    @options[:silent] = false
    opts.on( '--silent', 'Disable output while generating consumers' ) do
        @options[:silent] = true
    end

    opts.on('-?', '--help', 'Displays command and option information') do
        puts opts
        exit
    end
end

optparse.parse!

candlepin = Candlepin.new(
    @options[:user], @options[:password], nil, nil, @options[:server], @options[:port], nil,
    @options[:uuid], @options[:trused_user], @options[:context], @options[:ssl]
)

check_candlepin_configuration(candlepin)

if ARGV.length < 2
    log(optparse)
    exit
end

owner_key = ARGV.shift

# verify target owner exists, creating it as necessary
begin
    owner = candlepin.get_owner(owner_key)
rescue RestClient::ResourceNotFound
    log("Owner #{owner_key} does not exist; creating it...")
    owner = candlepin.create_owner(owner_key)
end

# If we need to clean the upstream subscription first
if @options[:clean]
    log("Clearing existing upstream subscription data")
    clear_upstream_data(candlepin)
end

# Inject subscriptions from all files provided
total = 0

ARGV.each do |json_file|
    log("Loading subscriptions from file #{json_file}...")

    # load subscriptions
    subscriptions = load_subscriptions(json_file)

    # Inject subscriptions
    count = 0

    subscriptions.each do |subscription|
        sid = subscription['id']
        sid = generate_subscription_id(json_file, count, subscription) if !sid

        count = count + 1
        log("Persisting data for subscription: #{sid}  (#{count} of #{subscriptions.length})")
        create_upstream_subscription(candlepin, sid, owner_key, subscription)
    end

    total = total + count
end

log("Finished!")
log("Persisted #{total} subscriptions for owner #{owner_key}")
