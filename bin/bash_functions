#! /bin/bash

RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
RESET_COLOR=$(tput sgr0)

err_msg() {
    echo "${RED}${1}${RESET_COLOR}" >&2
}

success_msg() {
    echo "${GREEN}${1}${RESET_COLOR}"
}

warn_msg() {
    echo "${YELLOW}${1}${RESET_COLOR}"
}

project_directory() {
    if [ -n "$1" ]; then
        qbuildr "project_root:$1"
    else
        qbuilder project_root
    fi
}

checkout_directory() {
    git rev-parse --show-toplevel
}

qbuildr() {
    # The implementation of "$*" has always been a problem and realistically
    # should have been replaced with the behavior of "$@". In almost every case
    # where coders use "$*", they mean "$@". "$*" Can cause bugs and even
    # security holes in your software.
    # http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html
    buildr -s "$@"
}

evalrc() {
    if [ "$1" -ne "0" ]; then
        echo "$2"
        exit $1
    fi
}

# Note that this function takes certificate strings as parameters
# and not the file names of certificate files!  Also note that when
# dealing with a certificate string, you should always quote the
# variable to preserve the newlines.
fingerprint() {
    local cert="$1"
    if [ -n "$cert" ]; then
        echo "$cert" | openssl x509 -noout -fingerprint | cut -d= -f2
    else
        echo ""
    fi
}

fp_file() {
    echo "$(fingerprint "$(cert_from_file "$@")")"
}

fp_nss() {
    echo "$(fingerprint "$(cert_from_nss "$@")")"
}

fp_jks() {
    echo "$(fingerprint "$(cert_from_jks "$@")")"
}

fp_pkcs12() {
    echo "$(fingerprint "$(cert_from_pkcs12 "$@")")"
}

cert_from_file() {
    if [ -e "$1" ]; then
        # Some cert files have other human readable junk in them.  I'm looking at you, Katello.
        openssl x509 -in "$1"
    else
        echo ""
    fi
}

cert_from_nss() {
    local db="$1"
    local cert_alias="$2"
    if [ -d "$db" ]; then
        sudo certutil -L -d "$db" -n "$cert_alias" -a 2> /dev/null || echo ""
    else
        echo ""
    fi
}

cert_from_jks() {
    local jks="$1"
    local cert_alias="$2"
    if [ -e "$jks" ]; then
        sudo keytool -exportcert -alias "$cert_alias" -keystore "$jks" -rfc -storepass "$JAVA_PASS"
    else
        echo ""
    fi
}

cert_from_pkcs12() {
    local pkcs12="$1"
    local name="$2"
    local password="${3:-password}"
    if [ -e "$pkcs12" ]; then
      # PKCS12 prints a bunch of junk at the top of the output that we don't want.
      sudo openssl pkcs12 -in "$pkcs12" -name "$name" -passin pass:$password -nokeys -nomacver | \
        awk -v RS='\0' '{print substr($0, match($0, /-----BEGIN.*/))}'
    else
        echo ""
    fi
}
